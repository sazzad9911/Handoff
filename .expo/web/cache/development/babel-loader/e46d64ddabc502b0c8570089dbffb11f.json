{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport Marker from \"./MapMarker\";\nimport Polyline from \"./MapPolyline\";\nimport Polygon from \"./MapPolygon\";\nimport { ColorPropType } from \"react-native-web/dist/index\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nvar propTypes = {\n  geojson: PropTypes.object.isRequired,\n  strokeColor: ColorPropType,\n  fillColor: ColorPropType,\n  strokeWidth: PropTypes.number,\n  lineDashPhase: PropTypes.number,\n  lineDashPattern: PropTypes.arrayOf(PropTypes.number),\n  lineCap: PropTypes.oneOf(['butt', 'round', 'square']),\n  lineJoin: PropTypes.oneOf(['miter', 'round', 'bevel']),\n  miterLimit: PropTypes.number,\n  zIndex: PropTypes.number,\n  onPress: PropTypes.func,\n  markerComponent: PropTypes.node\n};\n\nvar Geojson = function Geojson(props) {\n  var overlays = makeOverlays(props.geojson.features);\n  return _jsx(React.Fragment, {\n    children: overlays.map(function (overlay, index) {\n      var fillColor = getColor(props, overlay, 'fill', 'fillColor');\n      var strokeColor = getColor(props, overlay, 'stroke', 'strokeColor');\n      var markerColor = getColor(props, overlay, 'marker-color', 'color');\n      var strokeWidth = getStrokeWidth(props, overlay);\n\n      if (overlay.type === 'point') {\n        return _jsx(Marker, {\n          coordinate: overlay.coordinates,\n          image: props.image,\n          pinColor: markerColor,\n          zIndex: props.zIndex,\n          onPress: function onPress() {\n            return props.onPress && props.onPress(overlay);\n          },\n          children: props.markerComponent\n        }, index);\n      }\n\n      if (overlay.type === 'polygon') {\n        return _jsx(Polygon, {\n          coordinates: overlay.coordinates,\n          holes: overlay.holes,\n          strokeColor: strokeColor,\n          fillColor: fillColor,\n          strokeWidth: strokeWidth,\n          tappable: props.tappable,\n          onPress: function onPress() {\n            return props.onPress && props.onPress(overlay);\n          },\n          zIndex: props.zIndex\n        }, index);\n      }\n\n      if (overlay.type === 'polyline') {\n        return _jsx(Polyline, {\n          coordinates: overlay.coordinates,\n          strokeColor: strokeColor,\n          strokeWidth: strokeWidth,\n          lineDashPhase: props.lineDashPhase,\n          lineDashPattern: props.lineDashPattern,\n          lineCap: props.lineCap,\n          lineJoin: props.lineJoin,\n          miterLimit: props.miterLimit,\n          zIndex: props.zIndex,\n          tappable: props.tappable,\n          onPress: function onPress() {\n            return props.onPress && props.onPress(overlay);\n          }\n        }, index);\n      }\n    })\n  });\n};\n\nGeojson.propTypes = propTypes;\nexport default Geojson;\nexport var makeOverlays = function makeOverlays(features) {\n  var points = features.filter(function (f) {\n    return f.geometry && (f.geometry.type === 'Point' || f.geometry.type === 'MultiPoint');\n  }).map(function (feature) {\n    return makeCoordinates(feature).map(function (coordinates) {\n      return makeOverlay(coordinates, feature);\n    });\n  }).reduce(flatten, []).map(function (overlay) {\n    return _objectSpread(_objectSpread({}, overlay), {}, {\n      type: 'point'\n    });\n  });\n  var lines = features.filter(function (f) {\n    return f.geometry && (f.geometry.type === 'LineString' || f.geometry.type === 'MultiLineString');\n  }).map(function (feature) {\n    return makeCoordinates(feature).map(function (coordinates) {\n      return makeOverlay(coordinates, feature);\n    });\n  }).reduce(flatten, []).map(function (overlay) {\n    return _objectSpread(_objectSpread({}, overlay), {}, {\n      type: 'polyline'\n    });\n  });\n  var multipolygons = features.filter(function (f) {\n    return f.geometry && f.geometry.type === 'MultiPolygon';\n  }).map(function (feature) {\n    return makeCoordinates(feature).map(function (coordinates) {\n      return makeOverlay(coordinates, feature);\n    });\n  }).reduce(flatten, []);\n  var polygons = features.filter(function (f) {\n    return f.geometry && f.geometry.type === 'Polygon';\n  }).map(function (feature) {\n    return makeOverlay(makeCoordinates(feature), feature);\n  }).reduce(flatten, []).concat(multipolygons).map(function (overlay) {\n    return _objectSpread(_objectSpread({}, overlay), {}, {\n      type: 'polygon'\n    });\n  });\n  return points.concat(lines).concat(polygons);\n};\n\nvar flatten = function flatten(prev, curr) {\n  return prev.concat(curr);\n};\n\nvar makeOverlay = function makeOverlay(coordinates, feature) {\n  var overlay = {\n    feature: feature\n  };\n\n  if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n    overlay.coordinates = coordinates[0];\n\n    if (coordinates.length > 1) {\n      overlay.holes = coordinates.slice(1);\n    }\n  } else {\n    overlay.coordinates = coordinates;\n  }\n\n  return overlay;\n};\n\nvar makePoint = function makePoint(c) {\n  return {\n    latitude: c[1],\n    longitude: c[0]\n  };\n};\n\nvar makeLine = function makeLine(l) {\n  return l.map(makePoint);\n};\n\nvar makeCoordinates = function makeCoordinates(feature) {\n  var g = feature.geometry;\n\n  if (g.type === 'Point') {\n    return [makePoint(g.coordinates)];\n  } else if (g.type === 'MultiPoint') {\n    return g.coordinates.map(makePoint);\n  } else if (g.type === 'LineString') {\n    return [makeLine(g.coordinates)];\n  } else if (g.type === 'MultiLineString') {\n    return g.coordinates.map(makeLine);\n  } else if (g.type === 'Polygon') {\n    return g.coordinates.map(makeLine);\n  } else if (g.type === 'MultiPolygon') {\n    return g.coordinates.map(function (p) {\n      return p.map(makeLine);\n    });\n  } else {\n    return [];\n  }\n};\n\nvar doesOverlayContainProperty = function doesOverlayContainProperty(overlay, property) {\n  return overlay.feature && overlay.feature.properties && overlay.feature.properties[property];\n};\n\nvar getRgbaFromHex = function getRgbaFromHex(hex) {\n  var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n  var _hex$match$map = hex.match(/\\w\\w/g).map(function (x) {\n    return parseInt(x, 16);\n  }),\n      _hex$match$map2 = _slicedToArray(_hex$match$map, 3),\n      r = _hex$match$map2[0],\n      g = _hex$match$map2[1],\n      b = _hex$match$map2[2];\n\n  return \"rgba(\" + r + \",\" + g + \",\" + b + \",\" + alpha + \")\";\n};\n\nvar getColor = function getColor(props, overlay, colorType, overrideColorProp) {\n  if (props.hasOwnProperty(overrideColorProp)) {\n    return props[overrideColorProp];\n  }\n\n  if (doesOverlayContainProperty(overlay, colorType)) {\n    var color = overlay.feature.properties[colorType];\n    var opacityProperty = colorType + '-opacity';\n\n    if (doesOverlayContainProperty(overlay, opacityProperty) && color[0] === '#') {\n      color = getRgbaFromHex(color, overlay.feature.properties[opacityProperty]);\n    }\n\n    return color;\n  }\n\n  return null;\n};\n\nvar getStrokeWidth = function getStrokeWidth(props, overlay) {\n  if (props.hasOwnProperty('strokeWidth')) {\n    return props['strokeWidth'];\n  }\n\n  if (doesOverlayContainProperty(overlay, 'stroke-width')) {\n    return overlay.feature.properties['stroke-width'];\n  }\n\n  return 0;\n};","map":{"version":3,"sources":["C:/Project/HTML/MyProfile/Handoff/node_modules/react-native-maps/lib/components/Geojson.js"],"names":["React","PropTypes","Marker","Polyline","Polygon","ColorPropType","propTypes","geojson","object","isRequired","strokeColor","fillColor","strokeWidth","number","lineDashPhase","lineDashPattern","arrayOf","lineCap","oneOf","lineJoin","miterLimit","zIndex","onPress","func","markerComponent","node","Geojson","props","overlays","makeOverlays","features","map","overlay","index","getColor","markerColor","getStrokeWidth","type","coordinates","image","holes","tappable","points","filter","f","geometry","feature","makeCoordinates","makeOverlay","reduce","flatten","lines","multipolygons","polygons","concat","prev","curr","length","slice","makePoint","c","latitude","longitude","makeLine","l","g","p","doesOverlayContainProperty","property","properties","getRgbaFromHex","hex","alpha","match","x","parseInt","r","b","colorType","overrideColorProp","hasOwnProperty","color","opacityProperty"],"mappings":"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","sourcesContent":["import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport Marker from './MapMarker';\r\nimport Polyline from './MapPolyline';\r\nimport Polygon from './MapPolygon';\r\nimport { ColorPropType } from 'react-native';\r\n\r\nconst propTypes = {\r\n  /**\r\n   * [Geojson](https://geojson.org/) description of object.\r\n   */\r\n  geojson: PropTypes.object.isRequired,\r\n\r\n  /**\r\n   * The stroke color to use for the path.\r\n   */\r\n  strokeColor: ColorPropType,\r\n\r\n  /**\r\n   * The fill color to use for the path.\r\n   */\r\n  fillColor: ColorPropType,\r\n\r\n  /**\r\n   * The stroke width to use for the path.\r\n   */\r\n  strokeWidth: PropTypes.number,\r\n\r\n  /**\r\n   * The offset (in points) at which to start drawing the dash pattern.\r\n   *\r\n   * Use this property to start drawing a dashed line partway through a segment or gap. For\r\n   * example, a phase value of 6 for the patter 5-2-3-2 would cause drawing to begin in the\r\n   * middle of the first gap.\r\n   *\r\n   * The default value of this property is 0.\r\n   *\r\n   * @platform ios\r\n   */\r\n  lineDashPhase: PropTypes.number,\r\n\r\n  /**\r\n   * An array of numbers specifying the dash pattern to use for the path.\r\n   *\r\n   * The array contains one or more numbers that indicate the lengths (measured in points) of the\r\n   * line segments and gaps in the pattern. The values in the array alternate, starting with the\r\n   * first line segment length, followed by the first gap length, followed by the second line\r\n   * segment length, and so on.\r\n   *\r\n   * This property is set to `null` by default, which indicates no line dash pattern.\r\n   *\r\n   * @platform ios\r\n   */\r\n  lineDashPattern: PropTypes.arrayOf(PropTypes.number),\r\n\r\n  /**\r\n   * The line cap style to apply to the open ends of the path.\r\n   * The default style is `round`.\r\n   *\r\n   * @platform ios\r\n   */\r\n  lineCap: PropTypes.oneOf(['butt', 'round', 'square']),\r\n\r\n  /**\r\n   * The line join style to apply to corners of the path.\r\n   * The default style is `round`.\r\n   *\r\n   * @platform ios\r\n   */\r\n  lineJoin: PropTypes.oneOf(['miter', 'round', 'bevel']),\r\n\r\n  /**\r\n   * The limiting value that helps avoid spikes at junctions between connected line segments.\r\n   * The miter limit helps you avoid spikes in paths that use the `miter` `lineJoin` style. If\r\n   * the ratio of the miter length—that is, the diagonal length of the miter join—to the line\r\n   * thickness exceeds the miter limit, the joint is converted to a bevel join. The default\r\n   * miter limit is 10, which results in the conversion of miters whose angle at the joint\r\n   * is less than 11 degrees.\r\n   *\r\n   * @platform ios\r\n   */\r\n  miterLimit: PropTypes.number,\r\n\r\n  /**\r\n   * The order in which this tile overlay is drawn with respect to other overlays. An overlay\r\n   * with a larger z-index is drawn over overlays with smaller z-indices. The order of overlays\r\n   * with the same z-index is arbitrary. The default zIndex is 0.\r\n   *\r\n   * @platform android\r\n   */\r\n  zIndex: PropTypes.number,\r\n\r\n  /**\r\n   * Callback that is called when the user presses on the polygon\r\n   */\r\n  onPress: PropTypes.func,\r\n\r\n  /**\r\n   * Component to render in place of the default marker when the overlay type is a `point`\r\n   *\r\n   */\r\n  markerComponent: PropTypes.node,\r\n};\r\n\r\nconst Geojson = props => {\r\n  const overlays = makeOverlays(props.geojson.features);\r\n  return (\r\n    <React.Fragment>\r\n      {overlays.map((overlay, index) => {\r\n        const fillColor = getColor(props, overlay, 'fill', 'fillColor');\r\n        const strokeColor = getColor(props, overlay, 'stroke', 'strokeColor');\r\n        const markerColor = getColor(props, overlay, 'marker-color', 'color');\r\n        const strokeWidth = getStrokeWidth(props, overlay);\r\n        if (overlay.type === 'point') {\r\n          return (\r\n            <Marker\r\n              key={index}\r\n              coordinate={overlay.coordinates}\r\n              image={props.image}\r\n              pinColor={markerColor}\r\n              zIndex={props.zIndex}\r\n              onPress={() => props.onPress && props.onPress(overlay)}\r\n            >\r\n              {props.markerComponent}\r\n            </Marker>\r\n          );\r\n        }\r\n        if (overlay.type === 'polygon') {\r\n          return (\r\n            <Polygon\r\n              key={index}\r\n              coordinates={overlay.coordinates}\r\n              holes={overlay.holes}\r\n              strokeColor={strokeColor}\r\n              fillColor={fillColor}\r\n              strokeWidth={strokeWidth}\r\n              tappable={props.tappable}\r\n              onPress={() => props.onPress && props.onPress(overlay)}\r\n              zIndex={props.zIndex}\r\n            />\r\n          );\r\n        }\r\n        if (overlay.type === 'polyline') {\r\n          return (\r\n            <Polyline\r\n              key={index}\r\n              coordinates={overlay.coordinates}\r\n              strokeColor={strokeColor}\r\n              strokeWidth={strokeWidth}\r\n              lineDashPhase={props.lineDashPhase}\r\n              lineDashPattern={props.lineDashPattern}\r\n              lineCap={props.lineCap}\r\n              lineJoin={props.lineJoin}\r\n              miterLimit={props.miterLimit}\r\n              zIndex={props.zIndex}\r\n              tappable={props.tappable}\r\n              onPress={() => props.onPress && props.onPress(overlay)}\r\n            />\r\n          );\r\n        }\r\n      })}\r\n    </React.Fragment>\r\n  );\r\n};\r\n\r\nGeojson.propTypes = propTypes;\r\n\r\nexport default Geojson;\r\n\r\nexport const makeOverlays = features => {\r\n  const points = features\r\n    .filter(\r\n      f =>\r\n        f.geometry &&\r\n        (f.geometry.type === 'Point' || f.geometry.type === 'MultiPoint')\r\n    )\r\n    .map(feature =>\r\n      makeCoordinates(feature).map(coordinates =>\r\n        makeOverlay(coordinates, feature)\r\n      )\r\n    )\r\n    .reduce(flatten, [])\r\n    .map(overlay => ({ ...overlay, type: 'point' }));\r\n\r\n  const lines = features\r\n    .filter(\r\n      f =>\r\n        f.geometry &&\r\n        (f.geometry.type === 'LineString' ||\r\n          f.geometry.type === 'MultiLineString')\r\n    )\r\n    .map(feature =>\r\n      makeCoordinates(feature).map(coordinates =>\r\n        makeOverlay(coordinates, feature)\r\n      )\r\n    )\r\n    .reduce(flatten, [])\r\n    .map(overlay => ({ ...overlay, type: 'polyline' }));\r\n\r\n  const multipolygons = features\r\n    .filter(f => f.geometry && f.geometry.type === 'MultiPolygon')\r\n    .map(feature =>\r\n      makeCoordinates(feature).map(coordinates =>\r\n        makeOverlay(coordinates, feature)\r\n      )\r\n    )\r\n    .reduce(flatten, []);\r\n\r\n  const polygons = features\r\n    .filter(f => f.geometry && f.geometry.type === 'Polygon')\r\n    .map(feature => makeOverlay(makeCoordinates(feature), feature))\r\n    .reduce(flatten, [])\r\n    .concat(multipolygons)\r\n    .map(overlay => ({ ...overlay, type: 'polygon' }));\r\n\r\n  return points.concat(lines).concat(polygons);\r\n};\r\n\r\nconst flatten = (prev, curr) => prev.concat(curr);\r\n\r\nconst makeOverlay = (coordinates, feature) => {\r\n  let overlay = {\r\n    feature,\r\n  };\r\n  if (\r\n    feature.geometry.type === 'Polygon' ||\r\n    feature.geometry.type === 'MultiPolygon'\r\n  ) {\r\n    overlay.coordinates = coordinates[0];\r\n    if (coordinates.length > 1) {\r\n      overlay.holes = coordinates.slice(1);\r\n    }\r\n  } else {\r\n    overlay.coordinates = coordinates;\r\n  }\r\n  return overlay;\r\n};\r\n\r\nconst makePoint = c => ({ latitude: c[1], longitude: c[0] });\r\n\r\nconst makeLine = l => l.map(makePoint);\r\n\r\nconst makeCoordinates = feature => {\r\n  const g = feature.geometry;\r\n  if (g.type === 'Point') {\r\n    return [makePoint(g.coordinates)];\r\n  } else if (g.type === 'MultiPoint') {\r\n    return g.coordinates.map(makePoint);\r\n  } else if (g.type === 'LineString') {\r\n    return [makeLine(g.coordinates)];\r\n  } else if (g.type === 'MultiLineString') {\r\n    return g.coordinates.map(makeLine);\r\n  } else if (g.type === 'Polygon') {\r\n    return g.coordinates.map(makeLine);\r\n  } else if (g.type === 'MultiPolygon') {\r\n    return g.coordinates.map(p => p.map(makeLine));\r\n  } else {\r\n    return [];\r\n  }\r\n};\r\n\r\nconst doesOverlayContainProperty = (overlay, property) => {\r\n  // Geojson may have 0 for the opacity when intention is to not specify the\r\n  // opacity. Therefore, we evaluate the truthiness of the propery where 0\r\n  // would return false.\r\n  return (\r\n    overlay.feature &&\r\n    overlay.feature.properties &&\r\n    overlay.feature.properties[property]\r\n  );\r\n};\r\n\r\nconst getRgbaFromHex = (hex, alpha = 1) => {\r\n  const [r, g, b] = hex.match(/\\w\\w/g).map(x => parseInt(x, 16));\r\n  return `rgba(${r},${g},${b},${alpha})`;\r\n};\r\n\r\nconst getColor = (props, overlay, colorType, overrideColorProp) => {\r\n  if (props.hasOwnProperty(overrideColorProp)) {\r\n    return props[overrideColorProp];\r\n  }\r\n  if (doesOverlayContainProperty(overlay, colorType)) {\r\n    let color = overlay.feature.properties[colorType];\r\n    const opacityProperty = colorType + '-opacity';\r\n    if (\r\n      doesOverlayContainProperty(overlay, opacityProperty) &&\r\n      color[0] === '#'\r\n    ) {\r\n      color = getRgbaFromHex(\r\n        color,\r\n        overlay.feature.properties[opacityProperty]\r\n      );\r\n    }\r\n    return color;\r\n  }\r\n  return null;\r\n};\r\n\r\nconst getStrokeWidth = (props, overlay) => {\r\n  if (props.hasOwnProperty('strokeWidth')) {\r\n    return props['strokeWidth'];\r\n  }\r\n  if (doesOverlayContainProperty(overlay, 'stroke-width')) {\r\n    return overlay.feature.properties['stroke-width'];\r\n  }\r\n  return 0;\r\n};\r\n"]},"metadata":{},"sourceType":"module"}