{"ast":null,"code":"'use strict';\n\nvar NativeModules = require(\"../BatchedBridge/NativeModules\");\n\nimport invariant from 'invariant';\nvar turboModuleProxy = global.__turboModuleProxy;\n\nfunction requireModule(name, schema) {\n  if (!global.RN$Bridgeless) {\n    var legacyModule = NativeModules[name];\n\n    if (legacyModule != null) {\n      return legacyModule;\n    }\n  }\n\n  if (turboModuleProxy != null) {\n    var module = schema != null ? turboModuleProxy(name, schema) : turboModuleProxy(name);\n    return module;\n  }\n\n  return null;\n}\n\nexport function get(name) {\n  var schema = arguments.length === 2 ? arguments[1] : undefined;\n  return requireModule(name, schema);\n}\nexport function getEnforcing(name) {\n  var schema = arguments.length === 2 ? arguments[1] : undefined;\n  var module = requireModule(name, schema);\n  invariant(module != null, \"TurboModuleRegistry.getEnforcing(...): '\" + name + \"' could not be found. \" + 'Verify that a module by this name is registered in the native binary.');\n  return module;\n}","map":{"version":3,"sources":["C:/Project/HTML/MyProfile/Handoff/node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"],"names":["NativeModules","require","invariant","turboModuleProxy","global","__turboModuleProxy","requireModule","name","schema","RN$Bridgeless","legacyModule","module","get","arguments","length","undefined","getEnforcing"],"mappings":"AAUA;;AAEA,IAAMA,aAAa,GAAGC,OAAO,kCAA7B;;AAEA,OAAOC,SAAP,MAAsB,WAAtB;AAEA,IAAMC,gBAAgB,GAAGC,MAAM,CAACC,kBAAhC;;AAEA,SAASC,aAAT,CAAuCC,IAAvC,EAAqDC,MAArD,EAA+E;AAE7E,MAAI,CAACJ,MAAM,CAACK,aAAZ,EAA2B;AAEzB,QAAMC,YAAY,GAAGV,aAAa,CAACO,IAAD,CAAlC;;AACA,QAAIG,YAAY,IAAI,IAApB,EAA0B;AACxB,aAASA,YAAT;AACD;AACF;;AAED,MAAIP,gBAAgB,IAAI,IAAxB,EAA8B;AAC5B,QAAMQ,MAAU,GACdH,MAAM,IAAI,IAAV,GAAiBL,gBAAgB,CAACI,IAAD,EAAOC,MAAP,CAAjC,GAAkDL,gBAAgB,CAACI,IAAD,CADpE;AAEA,WAAOI,MAAP;AACD;;AAED,SAAO,IAAP;AACD;;AAED,OAAO,SAASC,GAAT,CAA6BL,IAA7B,EAA+C;AAUpD,MAAMC,MAAM,GAAGK,SAAS,CAACC,MAAV,KAAqB,CAArB,GAAyBD,SAAS,CAAC,CAAD,CAAlC,GAAwCE,SAAvD;AACA,SAAOT,aAAa,CAAIC,IAAJ,EAAUC,MAAV,CAApB;AACD;AAED,OAAO,SAASQ,YAAT,CAAsCT,IAAtC,EAAuD;AAU5D,MAAMC,MAAM,GAAGK,SAAS,CAACC,MAAV,KAAqB,CAArB,GAAyBD,SAAS,CAAC,CAAD,CAAlC,GAAwCE,SAAvD;AACA,MAAMJ,MAAM,GAAGL,aAAa,CAAIC,IAAJ,EAAUC,MAAV,CAA5B;AACAN,EAAAA,SAAS,CACPS,MAAM,IAAI,IADH,EAEP,6CAA2CJ,IAA3C,8BACE,uEAHK,CAAT;AAKA,SAAOI,MAAP;AACD","sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow strict\r\n * @format\r\n */\r\n\r\n'use strict';\r\n\r\nconst NativeModules = require('../BatchedBridge/NativeModules');\r\nimport type {TurboModule} from './RCTExport';\r\nimport invariant from 'invariant';\r\n\r\nconst turboModuleProxy = global.__turboModuleProxy;\r\n\r\nfunction requireModule<T: TurboModule>(name: string, schema?: ?$FlowFixMe): ?T {\r\n  // Bridgeless mode requires TurboModules\r\n  if (!global.RN$Bridgeless) {\r\n    // Backward compatibility layer during migration.\r\n    const legacyModule = NativeModules[name];\r\n    if (legacyModule != null) {\r\n      return ((legacyModule: $FlowFixMe): T);\r\n    }\r\n  }\r\n\r\n  if (turboModuleProxy != null) {\r\n    const module: ?T =\r\n      schema != null ? turboModuleProxy(name, schema) : turboModuleProxy(name);\r\n    return module;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport function get<T: TurboModule>(name: string): ?T {\r\n  /**\r\n   * What is Schema?\r\n   *\r\n   * @react-native/babel-plugin-codegen will parse the NativeModule\r\n   * spec, and pass in the generated schema as the second argument\r\n   * to this function. The schem will then be used to perform method\r\n   * dispatch on, and translate arguments/return to and from the Native\r\n   * TurboModule object.\r\n   */\r\n  const schema = arguments.length === 2 ? arguments[1] : undefined;\r\n  return requireModule<T>(name, schema);\r\n}\r\n\r\nexport function getEnforcing<T: TurboModule>(name: string): T {\r\n  /**\r\n   * What is Schema?\r\n   *\r\n   * @react-native/babel-plugin-codegen will parse the NativeModule\r\n   * spec, and pass in the generated schema as the second argument\r\n   * to this function. The schem will then be used to perform method\r\n   * dispatch on, and translate arguments/return to and from the Native\r\n   * TurboModule object.\r\n   */\r\n  const schema = arguments.length === 2 ? arguments[1] : undefined;\r\n  const module = requireModule<T>(name, schema);\r\n  invariant(\r\n    module != null,\r\n    `TurboModuleRegistry.getEnforcing(...): '${name}' could not be found. ` +\r\n      'Verify that a module by this name is registered in the native binary.',\r\n  );\r\n  return module;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}